// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview AI flow for generating marketing content from a restaurant's menu.
 *
 * - generateMarketingContent - A function that generates marketing content based on the menu.
 * - GenerateMarketingContentInput - The input type for the generateMarketingContent function.
 * - GenerateMarketingContentOutput - The return type for the generateMarketingContent function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const MenuItemSchema = z.object({
  name: z.string().describe('The name of the menu item.'),
  description: z.string().describe('The description of the menu item.'),
  imageUrl: z.string().optional().describe('An optional image URL for the menu item.'),
});

const GenerateMarketingContentInputSchema = z.object({
  menuItems: z.array(MenuItemSchema).describe("The list of selected menu items to feature."),
  contentType: z
    .enum(['blog post', 'social media update', 'recipe'])
    .describe('The type of marketing content to generate.'),
  tone: z
    .string()
    .optional()
    .describe('The desired tone of the content (e.g., professional, funny, casual).'),
});
export type GenerateMarketingContentInput = z.infer<typeof GenerateMarketingContentInputSchema>;

const GenerateMarketingContentOutputSchema = z.object({
  content: z.string().describe('The generated marketing content in Markdown format.'),
});
export type GenerateMarketingContentOutput = z.infer<typeof GenerateMarketingContentOutputSchema>;

export async function generateMarketingContent(
  input: GenerateMarketingContentInput
): Promise<GenerateMarketingContentOutput> {
  return generateMarketingContentFlow(input);
}

const generateMarketingContentPrompt = ai.definePrompt({
  name: 'generateMarketingContentPrompt',
  input: {schema: GenerateMarketingContentInputSchema},
  output: {schema: GenerateMarketingContentOutputSchema},
  prompt: `You are a marketing expert for restaurants. Your task is to generate an engaging {{contentType}} based on a selection of menu items.
The output must be in Markdown format.
If an image is provided for an item, you MUST include it in your response. Use Markdown format for the image: ![alt text](url).
For the alt text, use the item's name. For the url, you MUST use the full data URI string provided in the context for that item's image. Do NOT generate your own image URLs.

**Tone:** {{#if tone}}{{tone}}{{else}}Engaging and friendly{{/if}}

**Featured Menu Items:**
{{#each menuItems}}
- **{{name}}**: {{description}}
  {{#if imageUrl}}
  Image for context: {{media url=imageUrl}}
  Data URI to use for this image in your output: {{{imageUrl}}}
  {{/if}}
{{/each}}

Now, generate the {{contentType}} in valid Markdown.
`,
});

const generateMarketingContentFlow = ai.defineFlow(
  {
    name: 'generateMarketingContentFlow',
    inputSchema: GenerateMarketingContentInputSchema,
    outputSchema: GenerateMarketingContentOutputSchema,
  },
  async (input) => {
    const menuItemsWithDataUris = await Promise.all(
      input.menuItems.map(async (item) => {
        if (!item.imageUrl) {
          return item;
        }
        try {
          const response = await fetch(item.imageUrl);
          if (!response.ok) {
            console.warn(`Failed to fetch image for ${item.name}: ${response.statusText}`);
            return { ...item, imageUrl: undefined };
          }

          // Determine MIME type from response headers, fallback to guessing from URL
          let mimeType = response.headers.get('content-type');
          if (!mimeType || mimeType === 'binary/octet-stream') {
              if (item.imageUrl?.endsWith('.png')) mimeType = 'image/png';
              else if (item.imageUrl?.endsWith('.jpg') || item.imageUrl?.endsWith('.jpeg')) mimeType = 'image/jpeg';
              else if (item.imageUrl?.endsWith('.webp')) mimeType = 'image/webp';
              else mimeType = 'image/jpeg'; // Default fallback
          }
          
          const buffer = await response.arrayBuffer();
          const base64 = Buffer.from(buffer).toString('base64');
          const dataUri = `data:${mimeType};base64,${base64}`;

          return { ...item, imageUrl: dataUri };
        } catch (error: any) {
          console.error(`Error processing image for ${item.name}:`, error.message);
          return { ...item, imageUrl: undefined }; // Return item without image on any error
        }
      })
    );

    const processedInput = { ...input, menuItems: menuItemsWithDataUris };
    const { output } = await generateMarketingContentPrompt(processedInput);
    return output!;
  }
);
